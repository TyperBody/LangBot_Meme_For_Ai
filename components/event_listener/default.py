# Auto generated by LangBot Plugin SDK.
# Please refer to https://docs.langbot.app/en/plugin/dev/tutor.html for more details.
from __future__ import annotations

from langbot_plugin.api.entities.builtin.platform import message as platform_message
from langbot_plugin.api.entities.builtin.provider import message 
from langbot_plugin.api.definition.components.common.event_listener import EventListener
from langbot_plugin.api.entities import events, context


import json
import re
import random

test_mode = False

model = ""
meme_information_mode = "mode1"
meme_send_mode = "mode3"
meme_get_mode = "mode2"
Random_Mode_Probability = 100
Keyword_Mode_Probability = 100
Five_Dimension_Emotion_Probability_disgust = 80
Five_Dimension_Emotion_Probability_joy = 80
Five_Dimension_Emotion_Probability_sadness = 50
Five_Dimension_Emotion_Probability_anger = 0
Five_Dimension_Emotion_Probability_fear = 0

base64_for_json_meme = '''{ 
    "emotion_data": [ 
        { 
            "id": 1, 
            "base64": "base64==", 
            "emotion": "高兴"
        },
        { 
            "id": 2, 
            "base64": "base64==", 
            "emotion": "笨蛋"
        },
        { 
            "id": 3, 
            "base64": "base64==", 
            "emotion": "暧昧"
        }
    ]
}'''
github_repo = ""


#函数

def generate_random_number(min_val=1, max_val=100):
    """
    生成指定范围内的随机整数
    """
    return random.randint(min_val, max_val)

def Random_Mode(Random_Mode_Probability):
    return (Random_Mode_Probability > generate_random_number(1, 100))

def Keyword_Mode(Keyword_Mode_Probability):
    return (Keyword_Mode_Probability > generate_random_number(1, 100))

def Five_Dimension_Emotion(Five_Dimension_Emotion_Probability_disgust, Five_Dimension_Emotion_Probability_joy, 
                          Five_Dimension_Emotion_Probability_sadness, 
                          Five_Dimension_Emotion_Probability_anger, 
                          Five_Dimension_Emotion_Probability_fear, Five_Dimension_Emotion_Probability_disgust_get,
                          Five_Dimension_Emotion_Probability_joy_get, Five_Dimension_Emotion_Probability_sadness_get,
                          Five_Dimension_Emotion_Probability_anger_get, Five_Dimension_Emotion_Probability_fear_get):
    # 1. 计算每个情绪的综合权重
    disgust_weight = Five_Dimension_Emotion_Probability_disgust * Five_Dimension_Emotion_Probability_disgust_get / 100
    joy_weight = Five_Dimension_Emotion_Probability_joy * Five_Dimension_Emotion_Probability_joy_get / 100
    sadness_weight = Five_Dimension_Emotion_Probability_sadness * Five_Dimension_Emotion_Probability_sadness_get / 100
    anger_weight = Five_Dimension_Emotion_Probability_anger * Five_Dimension_Emotion_Probability_anger_get / 100
    fear_weight = Five_Dimension_Emotion_Probability_fear * Five_Dimension_Emotion_Probability_fear_get / 100
    
    # 2. 计算总权重（限制在0-100范围内）
    total_weight = min(100, disgust_weight + joy_weight + sadness_weight + anger_weight + fear_weight)
    
    # 3. 生成随机数
    random_num = generate_random_number(1, 100)
    
    # 4. 判断是否发送图片
    should_send = random_num <= total_weight
    
    if test_mode:
        print(f"五维情绪权重计算:")
        print(f"  厌恶权重: {disgust_weight:.2f} (触发:{Five_Dimension_Emotion_Probability_disgust}, 占比:{Five_Dimension_Emotion_Probability_disgust_get})")
        print(f"  喜悦权重: {joy_weight:.2f} (触发:{Five_Dimension_Emotion_Probability_joy}, 占比:{Five_Dimension_Emotion_Probability_joy_get})")
        print(f"  悲伤权重: {sadness_weight:.2f} (触发:{Five_Dimension_Emotion_Probability_sadness}, 占比:{Five_Dimension_Emotion_Probability_sadness_get})")
        print(f"  愤怒权重: {anger_weight:.2f} (触发:{Five_Dimension_Emotion_Probability_anger}, 占比:{Five_Dimension_Emotion_Probability_anger_get})")
        print(f"  恐惧权重: {fear_weight:.2f} (触发:{Five_Dimension_Emotion_Probability_fear}, 占比:{Five_Dimension_Emotion_Probability_fear_get})")
        print(f"  总权重: {total_weight:.2f}, 随机数: {random_num}, 发送图片: {should_send}")
    
    return should_send


def fix_json_syntax(json_string):
    """
    修复JSON语法错误，特别是尾随逗号问题
    """
    # 移除对象和数组中的尾随逗号
    json_string = re.sub(r',\s*([}\]])', r'\1', json_string)
    # 移除对象和数组开头的逗号
    json_string = re.sub(r'([{\[])\s*,', r'\1', json_string)
    return json_string

def load_large_json(json_string):
    """
    加载超长JSON字符串并解析为Python对象
    """
    try:
        # 先尝试直接解析
        return json.loads(json_string)
    except json.JSONDecodeError as e:
        print(f"JSON解析错误: {e}")
        # 尝试修复语法错误
        fixed_json = fix_json_syntax(json_string)
        try:
            return json.loads(fixed_json)
        except json.JSONDecodeError as e2:
            print(f"修复后仍然解析错误: {e2}")
            return None

def get_all_emotions(json_data):
    """
    获取所有的emotion值
    """
    if not json_data or "emotion_data" not in json_data:
        return []
    
    emotions = []
    for item in json_data["emotion_data"]:
        if "emotion" in item:
            emotions.append(item["emotion"])
    
    return list(set(emotions))  # 去重

def get_base64_by_emotion(json_data, emotion):
    """
    通过emotion获取对应的base64
    返回列表，因为可能有多个相同emotion的条目
    """
    if not json_data or "emotion_data" not in json_data:
        return []
    
    results = []
    for item in json_data["emotion_data"]:
        if "emotion" in item and item["emotion"] == emotion and "base64" in item:
            results.append({
                "id": item.get("id", 0),
                "base64": item["base64"],
                "emotion": emotion
            })
    
    return results

def get_base64_by_id(json_data, id_value):
    """
    通过id获取对应的base64
    """
    if not json_data or "emotion_data" not in json_data:
        return None
    
    for item in json_data["emotion_data"]:
        if "id" in item and item["id"] == id_value and "base64" in item:
            return {
                "id": id_value,
                "base64": item["base64"],
                "emotion": item.get("emotion", "")
            }
    
    return None

def process_json_string(json_string):
    """
    主处理函数：输入JSON字符串，返回处理结果
    """
    # 解析JSON
    json_data = load_large_json(json_string)
    if not json_data:
        return {"error": "JSON解析失败"}
    
    # 获取所有emotion
    all_emotions = get_all_emotions(json_data)
    
    return {
        "json_data": json_data,
        "all_emotions": all_emotions,
        "total_items": len(json_data.get("emotion_data", [])),
        "functions": {
            "get_base64_by_emotion": get_base64_by_emotion,
            "get_base64_by_id": get_base64_by_id
        }
    }

class config:
    def __init__(self):
        super().__init__()
        
    async def initialize(self):
        await super().initialize()

        #获取默认配置
        config = self.plugin.get_config()
        #拆分配置
        global meme_information_mode,meme_send_mode,meme_get_mode,Random_Mode_Probability,Keyword_Mode_Probability,Five_Dimension_Emotion_Probability_disgust,Five_Dimension_Emotion_Probability_joy,Five_Dimension_Emotion_Probability_sadness,Five_Dimension_Emotion_Probability_anger,Five_Dimension_Emotion_Probability_fear,base64_for_json_meme,github_repo,model
        meme_information_mode = config.get("meme_information_mode", "mode1")
        meme_send_mode = config.get("meme_send_mode", "mode1")
        meme_get_mode = config.get("meme_get_mode", "mode2")
        Random_Mode_Probability = config.get("Random_Mode_Probability", 100)
        Keyword_Mode_Probability = config.get("Keyword_Mode_Probability", 100)
        Five_Dimension_Emotion_Probability_disgust = config.get("Five_Dimension_Emotion_Probability_disgust", 100)
        Five_Dimension_Emotion_Probability_joy = config.get("Five_Dimension_Emotion_Probability_joy", 100)
        Five_Dimension_Emotion_Probability_sadness = config.get("Five_Dimension_Emotion_Probability_sadness", 100)
        Five_Dimension_Emotion_Probability_anger = config.get("Five_Dimension_Emotion_Probability_anger", 100)
        Five_Dimension_Emotion_Probability_fear = config.get("Five_Dimension_Emotion_Probability_fear", 100)
        base64_for_json_meme = config.get("base64_for_json_meme", "")
        github_repo = config.get("github_repo", "")
        model = config.get("model", "")
        if test_mode:
            print(f"meme_send_mode: {meme_get_mode}")
        return 0

class DefaultEventListener(
    EventListener
):
    global meme_information_mode,meme_send_mode,meme_get_mode,Random_Mode_Probability,Keyword_Mode_Probability,Five_Dimension_Emotion_Probability_disgust, Five_Dimension_Emotion_Probability_joy, Five_Dimension_Emotion_Probability_sadness, Five_Dimension_Emotion_Probability_anger,Five_Dimension_Emotion_Probability_fear, base64_for_json_meme,github_repo,model
    
    config()
    async def initialize(self):
        await super().initialize()

        global next_meme
        next_meme = False
        result_json_number = 0

        if meme_get_mode == "mode1":
            #暂时懒得设计
            pass
        if meme_get_mode == "mode2":
            #此处省略一大堆base64_for_json_meme处理逻辑
            result_json = process_json_string(base64_for_json_meme)

            if "error" not in result_json:
                emoji_keywords = result_json["all_emotions"]
            else:
                print(result_json["error"])
                result_json_number = result_json["total_items"]
                emoji_keywords = []

        @self.handler(events.PromptPreProcessing)
        async def handler(event_context):
            event_data = event_context.event.default_prompt
            if test_mode:
                print(event_data)
                print(base64_for_json_meme)
            if meme_send_mode == "mode1" and Random_Mode:
                #不调用api
                global next_meme
                next_meme = True
            if meme_send_mode == "mode2" and Keyword_Mode: 
                if meme_information_mode == "mode1":
                    next_meme = True
                    mode2_message = message.Message(
                        role="system",
                        content=f'在每次对话最后加入标准json,确保括号数量正确,其内容应为{{"emotion": {{"keyword": "" }} }}并且其内容应该在{emoji_keywords}内,保证在情绪关键词相近的情况下每次触发不同的情绪关键词,如果是理性分析内容,则内容为NaN'
                    )

                    event_context.event.default_prompt.append(mode2_message)

                    event_data = event_context.event.default_prompt
                    if test_mode:
                        print(event_data)
                if meme_information_mode == "mode2":
                    next_meme = True
            if meme_send_mode == "mode3":
                if meme_information_mode == "mode1":
                    next_meme = True
                    mode3_message = message.Message(
                        role="system",
                        content=f'在每次对话最后加入标准json,确保括号数量正确,其内容应为{{"emotion": {{"keyword": "" }} ,"emotion_disgust": number,"emotion_joy": number,"emotion_sadness": number,"emotion_anger": number,"emotion_fear": number}}并且其内容应该在{emoji_keywords}内,保证在情绪关键词相近的情况下每次触发不同的情绪关键词,如果是理性分析内容,则内容为NaN,json中对应五维情绪字段中“number”应替换为当前选择的“keyword”或者当前对话对应情绪占比,“number”是应在1-100之间的数字'
                    )

                    event_context.event.default_prompt.append(mode3_message)

                    event_data = event_context.event.default_prompt
                    if test_mode:
                        print(event_data)
                if meme_information_mode == "mode2":
                    next_meme = True

        @self.handler(events.NormalMessageResponded)
        async def handler(event_context):
            response_text = event_context.event.response_text

            if test_mode:
                print(response_text)

            json_pattern = r'\{[^{}]*"emotion"[^{}]*\{[^{}]*"keyword"[^{}]*"[^"]*"[^{}]*\}[^{}]*\}'

            json_pattern_five = r'\{[^{}]*"emotion"[^{}]*\{[^{}]*"keyword"[^{}]*"[^"]*"[^{}]*\}[^{}]*,"emotion_disgust":\s*\d+[^{}]*,"emotion_joy":\s*\d+[^{}]*,"emotion_sadness":\s*\d+[^{}]*,"emotion_anger":\s*\d+[^{}]*,"emotion_fear":\s*\d+[^{}]*\}'

            global next_meme

            if meme_send_mode == "mode1" and next_meme:
                id_result = result_json["functions"]["get_base64_by_id"](result_json["json_data"], generate_random_number(1,result_json_number))
                await event_context.reply(
                    platform_message.MessageChain([
                        platform_message.Image(base64=id_result["base64"]),
                    ])
                )
            if meme_send_mode == "mode2" and next_meme:
                if meme_information_mode == "mode1":
                    matches = re.findall(json_pattern, response_text)
            
                    if matches:
                        # 取最后一个匹配的JSON
                        extracted_json = matches[-1]
                        
                        # 从原文本中移除JSON
                        cleaned_text = response_text.replace(extracted_json, '').strip()
                        
                        # 解析JSON
                        try:
                            emotion_data = json.loads(extracted_json)
                            keyword = emotion_data.get("emotion", {}).get("keyword", "")
                            if test_mode:
                                print(f"提取的关键词: {keyword}")
                        except:
                            if test_mode:
                                print("JSON解析失败")
                        if test_mode:
                            print(f"提取的JSON: {extracted_json}")
                            print(f"清理后的文本: {cleaned_text}")
                    else:
                        if test_mode:
                            print("未找到JSON")
                    if test_mode:        
                        print(cleaned_text)
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=cleaned_text)
                        ])
                    )
                    if matches:
                        emotion_results = result_json["functions"]["get_base64_by_emotion"](result_json["json_data"], keyword)
                        # 修复：emotion_results是列表，需要选择第一个结果或随机选择一个
                        if emotion_results:
                            # 随机选择一个结果
                            selected_result = emotion_results[generate_random_number(0, len(emotion_results) - 1)]
                            await event_context.reply(
                                platform_message.MessageChain([
                                    platform_message.Image(base64=selected_result["base64"]),
                                ])
                            )
                            print("发送成功")
                        else:
                            if test_mode:
                                print(f"未找到与关键词 '{keyword}' 对应的图片")
                if meme_information_mode == "mode2":
                    from langbot_plugin.api.entities.builtin.provider import message as provider_message
                    llm_message = await self.plugin.invoke_llm(
                        llm_model_uuid=model,
                        messages=[
                            provider_message.Message(
                                role="user", content=response_text+f'/n分析以上消息情绪,只返回一个标准json,确保括号数量正确其内容应为{{"emotion": {{"keyword": "" }} }}并且其内容应该在{emoji_keywords}内,保证在情绪关键词相近的情况下每次触发不同的情绪关键词,如果是理性分析内容,则内容为NaN')
                            ],
                        funcs=[],
                        extra_args={},
                    )
                    matches = re.findall(json_pattern, llm_message)
            
                    if matches:
                        # 取最后一个匹配的JSON
                        extracted_json = matches[-1]
                        
                        # 解析JSON
                        try:
                            emotion_data = json.loads(extracted_json)
                            keyword = emotion_data.get("emotion", {}).get("keyword", "")
                            if test_mode:
                                print(f"提取的关键词: {keyword}")
                        except:
                            if test_mode:
                                print("JSON解析失败")
                        if test_mode:
                            print(f"提取的JSON: {extracted_json}")
                    else:
                        if test_mode:
                            print("未找到JSON")
                    if matches:
                        emotion_results = result_json["functions"]["get_base64_by_emotion"](result_json["json_data"], keyword)
                        # 修复：emotion_results是列表，需要选择第一个结果或随机选择一个
                        if emotion_results:
                            # 随机选择一个结果
                            selected_result = emotion_results[generate_random_number(0, len(emotion_results) - 1)]
                            await event_context.reply(
                                platform_message.MessageChain([
                                    platform_message.Image(base64=selected_result["base64"]),
                                ])
                            )
                        else:
                            if test_mode:
                                print(f"未找到与关键词 '{keyword}' 对应的图片")
            if meme_send_mode == "mode3" and next_meme:
                if meme_information_mode == "mode1":
                    matches = re.findall(json_pattern_five, response_text)

                    if matches:
                        # 取最后一个匹配的JSON
                        extracted_json = matches[-1]
                        
                        # 从原文本中移除JSON
                        cleaned_text = response_text.replace(extracted_json, '').strip()
                        
                        # 解析JSON
                        try:
                            emotion_data = json.loads(extracted_json)
                            keyword = emotion_data.get("emotion", {}).get("keyword", "")
                            emotion_disgust = emotion_data.get("emotion_disgust", 0)
                            emotion_joy = emotion_data.get("emotion_joy", 0)
                            emotion_sadness = emotion_data.get("emotion_sadness", 0)
                            emotion_anger = emotion_data.get("emotion_anger", 0)
                            emotion_fear = emotion_data.get("emotion_fear", 0)
                            if test_mode:
                                print(f"提取的关键词: {keyword}")
                                print(f"emotion_disgust: {emotion_disgust}")
                                print(f"emotion_joy: {emotion_joy}")
                                print(f"emotion_sadness: {emotion_sadness}")
                                print(f"emotion_anger: {emotion_anger}")
                                print(f"emotion_fear: {emotion_fear}")
                        except:
                            if test_mode:
                                print("JSON解析失败")
                        if test_mode:
                            print(f"提取的JSON: {extracted_json}")
                            print(f"清理后的文本: {cleaned_text}")
                    else:
                        if test_mode:
                            print("未找到JSON")
                    if test_mode:        
                        print(cleaned_text)
                    await event_context.reply(
                        platform_message.MessageChain([
                            platform_message.Plain(text=cleaned_text)
                        ])
                    )
                    if matches and Five_Dimension_Emotion(Five_Dimension_Emotion_Probability_disgust,Five_Dimension_Emotion_Probability_joy,Five_Dimension_Emotion_Probability_sadness,Five_Dimension_Emotion_Probability_anger,Five_Dimension_Emotion_Probability_fear,emotion_disgust,emotion_joy,emotion_sadness,emotion_anger,emotion_fear):
                        emotion_results = result_json["functions"]["get_base64_by_emotion"](result_json["json_data"], keyword)
                        # 修复：emotion_results是列表，需要选择第一个结果或随机选择一个
                        if emotion_results:
                            # 随机选择一个结果
                            selected_result = emotion_results[generate_random_number(0, len(emotion_results) - 1)]
                            await event_context.reply(
                                platform_message.MessageChain([
                                    platform_message.Image(base64=selected_result["base64"]),
                                ])
                            )
                            print("发送成功")
                        else:
                            if test_mode:
                                print(f"未找到与关键词 '{keyword}' 对应的图片")

                if meme_information_mode == "mode2":
                    from langbot_plugin.api.entities.builtin.provider import message as provider_message
                    llm_message = await self.plugin.invoke_llm(
                        llm_model_uuid=model,
                        messages=[
                            provider_message.Message(
                                role="user", content=response_text+f'/n分析以上消息情绪,只返回一个标准json,确保括号数量正确,其内容应为{{"emotion": {{"keyword": "" }} ,"emotion_disgust": number,"emotion_joy": number,"emotion_sadness": number,"emotion_anger": number,"emotion_fear": number}}并且其内容应该在{emoji_keywords}内,保证在情绪关键词相近的情况下每次触发不同的情绪关键词,如果是理性分析内容,则内容为NaN,json中对应五维情绪字段中“number”应替换为当前选择的“keyword”或者当前对话对应情绪占比,“number”是应在1-100之间的数字')
                            ],
                        funcs=[],
                        extra_args={},
                    )
                    matches = re.findall(json_pattern_five, llm_message)

                    if matches:
                        # 取最后一个匹配的JSON
                        extracted_json = matches[-1]
                        
                        # 解析JSON
                        try:
                            emotion_data = json.loads(extracted_json)
                            keyword = emotion_data.get("emotion", {}).get("keyword", "")
                            emotion_disgust = emotion_data.get("emotion_disgust", 0)
                            emotion_joy = emotion_data.get("emotion_joy", 0)
                            emotion_sadness = emotion_data.get("emotion_sadness", 0)
                            emotion_anger = emotion_data.get("emotion_anger", 0)
                            emotion_fear = emotion_data.get("emotion_fear", 0)
                            if test_mode:
                                print(f"提取的关键词: {keyword}")
                                print(f"emotion_disgust: {emotion_disgust}")
                                print(f"emotion_joy: {emotion_joy}")
                                print(f"emotion_sadness: {emotion_sadness}")
                                print(f"emotion_anger: {emotion_anger}")
                                print(f"emotion_fear: {emotion_fear}")
                        except:
                            if test_mode:
                                print("JSON解析失败")
                        if test_mode:
                            print(f"提取的JSON: {extracted_json}")
                    else:
                        if test_mode:
                            print("未找到JSON")
                    if matches and Five_Dimension_Emotion(Five_Dimension_Emotion_Probability_disgust,Five_Dimension_Emotion_Probability_joy,Five_Dimension_Emotion_Probability_sadness,Five_Dimension_Emotion_Probability_anger,Five_Dimension_Emotion_Probability_fear,emotion_disgust,emotion_joy,emotion_sadness,emotion_anger,emotion_fear):
                        emotion_results = result_json["functions"]["get_base64_by_emotion"](result_json["json_data"], keyword)
                        # 修复：emotion_results是列表，需要选择第一个结果或随机选择一个
                        if emotion_results:
                            # 随机选择一个结果
                            selected_result = emotion_results[generate_random_number(0, len(emotion_results) - 1)]
                            await event_context.reply(
                                platform_message.MessageChain([
                                    platform_message.Image(base64=selected_result["base64"]),
                                ])
                            )
                        else:
                            if test_mode:
                                print(f"未找到与关键词 '{keyword}' 对应的图片")